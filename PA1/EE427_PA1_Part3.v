
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module EE427_PA1_Part3(

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX5,

	//////////// SW //////////
	input 		     [9:0]		SW
);



//=======================================================
//  REG/WIRE declarations
//=======================================================


//=======================================================
//  Structural coding
//=======================================================

wire t0 [4:0];
wire z0 [3:0];
wire c1 [3:0];
wire s0 [3:0];

                                               
rippleAdder(SW[7], SW[6], SW[5], SW[4], SW[3], SW[2], SW[1], SW[0], SW[8], t0[4], t0[3], t0[2], t0[1], t0[0]);

comparator(t0[4], t0[3], t0[2], t0[1], t0[0], z);
		
multiplex(z, z0[3], z0[2], z0[1], z0[0], c1[3], c1[2], c1[1], c1[0]);
		
rippleSubtractor(z, t0[3], t0[2], t0[1], t0[0], z0[3], z0[2], z0[1], z0[0], s0[3], s0[2], s0[1], s0[0]);

Seg7(s0[3], s0[2], s0[1], s0[0], HEX0[0], HEX0[1], HEX0[2], HEX0[3], HEX0[4], HEX0[5], HEX0[6]); // hex0, t0
Seg7(c1[3], c1[2], c1[1], c1[0], HEX1[0], HEX1[1], HEX1[2], HEX1[3], HEX1[4], HEX1[5], HEX1[6]); // hex1, s1

Seg7(SW[7], SW[6], SW[5], SW[4], HEX5[0], HEX5[1], HEX5[2], HEX5[3], HEX5[4], HEX5[5], HEX5[6]); // hex5, a
Seg7(SW[3], SW[2], SW[1], SW[0], HEX3[0], HEX3[1], HEX3[2], HEX3[3], HEX3[4], HEX3[5], HEX3[6]); // hex3, b


endmodule

module fullAdder(
	input a, b, c_in,
	output s, c_out);
	
	wire s1, c1, c2, c3;
	
	xor xor_s1(s1, a, b);
	xor xor_s2(s, s1, c_in);
	and and_c1(c1, a, b);
	and and_c2(c2, a, c_in);
	and and_c3(c3, b, c_in);
	or or_cout(c_out, c1, c2, c3);
endmodule

// modified no more c_out, c_out is used as s4
module rippleAdder(
	input a3, a2, a1, a0, b3, b2, b1, b0, c_in,
	output s4, s3, s2, s1, s0);
	
	wire w0, w1, w2;
	
	fullAdder fa0(a0, b0, c_in, s0, w0); // LSB
	fullAdder fa1(a1, b1, w0, s1, w1);
	fullAdder fa2(a2, b2, w1, s2, w2);
	fullAdder fa3(a3, b3, w2, s3, s4); // MSB
	
endmodule

module rippleSubtractor(
	input z, a3, a2, a1, a0, b3, b2, b1, b0,
	output s3, s2, s1, s0);
	
	wire w0, w1, w2, w3;
	wire y0, y1, y2, y3, y4;
	
	// if z = 0 then just do normal addition
	// if z = 1 then do subtraction!
	
	assign y0 = z ? ~b0 : b0;
	assign y1 = z ? ~b1 : b1;
	assign y2 = z ? ~b2 : b2;
	assign y3 = z ? ~b3 : b3;
	
	fullAdder fa0(a0, y0, z, s0, w0); // LSB
	fullAdder fa1(a1, y1, w0, s1, w1);
	fullAdder fa2(a2, y2, w1, s2, w2);
	fullAdder fa3(a3, y3, w2, s3, w3); // MSB
	
endmodule
	
// 5 - bit comparator
module comparator(
	input v4, v3, v2, v1, v0,
	output z); 
	assign z = v4 | (v3 & v2) | (v3 & v1);
	
endmodule


module multiplex(
	input z,
	output x3, x2, x1, x0, c3, c2, c1, c0);
		
	assign x3 = z ? 1 : 0;
	assign x2 = z ? 0 : 0;
	assign x1 = z ? 1 : 0;
	assign x0 = z ? 0 : 0;
	
	assign c3 = z ? 0 : 0;
	assign c2 = z ? 0 : 0;
	assign c1 = z ? 0 : 0;
	assign c0 = z ? 1 : 0;
	
endmodule


module Seg7(
	input c, d, a, b,
	output seg0, seg1, seg2, seg3, seg4, seg5, seg6);
	
	assign seg0 = (~a & b & ~c & ~d) | (~a & ~b & ~c & d) | (a & ~b & c & d) | (a & b & c & ~d);
	assign seg1 = (~a & b & ~c & d) | (a & ~b & ~c & d) | (a & b & c & d);
	assign seg2 = (a & ~b & ~c & ~d) | (~a & ~b & c & d);
	assign seg3 = (b & c & ~d) | (~a & b & ~d) | (~a & ~b & ~c & d) | (a & b & ~c & d) | (a & ~b & c & d);
	assign seg4 = b | (a & c & d) | (~a & ~c & d);
	assign seg5 = (b & ~c & ~d) | (a & ~c & ~d) | (a & b & ~c) | (~a & c & d) | (a & b & ~d);
	assign seg6 = (~a & ~c & ~d) | (a & c & ~d) | (a & b & ~c & d);
	
endmodule

